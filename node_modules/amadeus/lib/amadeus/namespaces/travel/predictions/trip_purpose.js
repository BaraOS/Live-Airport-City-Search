"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A namespaced client for the
 * `/v1/travel/predictions/trip-purpose` endpoints
 *
 * Access via the {@link Amadeus} object
 *
 * ```js
 * let amadeus = new Amadeus();
 * amadeus.travel.predictions.tripPurpose;
 * ```
 *
 * @param {Client} client
 */
var TripPurpose =
/*#__PURE__*/
function () {
  function TripPurpose(client) {
    _classCallCheck(this, TripPurpose);

    this.client = client;
  }
  /**
   * Forecast traveler purpose, Business or Leisure, together with the probability in the context of search & shopping.
   *
   * @param {Object} params
   * @param {string} params.originLocationCode city/airport IATA code from which the traveler will depart, e.g. BOS for Boston
   * @param {string} params.destinationLocationCode city/airport IATA code to which the traveler is going, e.g. PAR for Paris
   * @param {string} params.departureDate the date on which the traveler will depart from the origin to go to the destination. Dates are specified in the ISO 8601 YYYY-MM-DD format, e.g. 2017-12-25
   * @param {string} params.returnDate the date on which the traveler will depart from the destination to return to the origin. Dates are specified in the ISO 8601 YYYY-MM-DD format, e.g. 2018-02-28
   * @return {Promise.<Response,ResponseError>} a Promise
   *
   * Forecast traveler purpose for a NYC-MAD round-trip between 2020-08-01 & 2020-08-12.
   *
   * ```js
   * amadeus.travel.predictions.tripPurpose.get({
   *    originLocationCode: 'NYC',
   *    destinationLocationCode: 'MAD',
   *    departureDate: '2020-08-01',
   *    returnDate: '2020-08-12'
   * })
   * ```
   */


  _createClass(TripPurpose, [{
    key: "get",
    value: function get() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.client.get('/v1/travel/predictions/trip-purpose', params);
    }
  }]);

  return TripPurpose;
}();

var _default = TripPurpose;
exports["default"] = _default;
module.exports = exports["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hbWFkZXVzL25hbWVzcGFjZXMvdHJhdmVsL3ByZWRpY3Rpb25zL3RyaXBfcHVycG9zZS5qcyJdLCJuYW1lcyI6WyJUcmlwUHVycG9zZSIsImNsaWVudCIsInBhcmFtcyIsImdldCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0lBYU1BLFc7OztBQUNKLHVCQUFZQyxNQUFaLEVBQW9CO0FBQUE7O0FBQ2xCLFNBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBcUJpQjtBQUFBLFVBQWJDLE1BQWEsdUVBQUosRUFBSTtBQUNmLGFBQU8sS0FBS0QsTUFBTCxDQUFZRSxHQUFaLENBQWdCLHFDQUFoQixFQUF1REQsTUFBdkQsQ0FBUDtBQUNEOzs7Ozs7ZUFHWUYsVyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBuYW1lc3BhY2VkIGNsaWVudCBmb3IgdGhlXG4gKiBgL3YxL3RyYXZlbC9wcmVkaWN0aW9ucy90cmlwLXB1cnBvc2VgIGVuZHBvaW50c1xuICpcbiAqIEFjY2VzcyB2aWEgdGhlIHtAbGluayBBbWFkZXVzfSBvYmplY3RcbiAqXG4gKiBgYGBqc1xuICogbGV0IGFtYWRldXMgPSBuZXcgQW1hZGV1cygpO1xuICogYW1hZGV1cy50cmF2ZWwucHJlZGljdGlvbnMudHJpcFB1cnBvc2U7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50XG4gKi9cbmNsYXNzIFRyaXBQdXJwb3NlIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogRm9yZWNhc3QgdHJhdmVsZXIgcHVycG9zZSwgQnVzaW5lc3Mgb3IgTGVpc3VyZSwgdG9nZXRoZXIgd2l0aCB0aGUgcHJvYmFiaWxpdHkgaW4gdGhlIGNvbnRleHQgb2Ygc2VhcmNoICYgc2hvcHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5vcmlnaW5Mb2NhdGlvbkNvZGUgY2l0eS9haXJwb3J0IElBVEEgY29kZSBmcm9tIHdoaWNoIHRoZSB0cmF2ZWxlciB3aWxsIGRlcGFydCwgZS5nLiBCT1MgZm9yIEJvc3RvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc3RpbmF0aW9uTG9jYXRpb25Db2RlIGNpdHkvYWlycG9ydCBJQVRBIGNvZGUgdG8gd2hpY2ggdGhlIHRyYXZlbGVyIGlzIGdvaW5nLCBlLmcuIFBBUiBmb3IgUGFyaXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXBhcnR1cmVEYXRlIHRoZSBkYXRlIG9uIHdoaWNoIHRoZSB0cmF2ZWxlciB3aWxsIGRlcGFydCBmcm9tIHRoZSBvcmlnaW4gdG8gZ28gdG8gdGhlIGRlc3RpbmF0aW9uLiBEYXRlcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBJU08gODYwMSBZWVlZLU1NLUREIGZvcm1hdCwgZS5nLiAyMDE3LTEyLTI1XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucmV0dXJuRGF0ZSB0aGUgZGF0ZSBvbiB3aGljaCB0aGUgdHJhdmVsZXIgd2lsbCBkZXBhcnQgZnJvbSB0aGUgZGVzdGluYXRpb24gdG8gcmV0dXJuIHRvIHRoZSBvcmlnaW4uIERhdGVzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIElTTyA4NjAxIFlZWVktTU0tREQgZm9ybWF0LCBlLmcuIDIwMTgtMDItMjhcbiAgICogQHJldHVybiB7UHJvbWlzZS48UmVzcG9uc2UsUmVzcG9uc2VFcnJvcj59IGEgUHJvbWlzZVxuICAgKlxuICAgKiBGb3JlY2FzdCB0cmF2ZWxlciBwdXJwb3NlIGZvciBhIE5ZQy1NQUQgcm91bmQtdHJpcCBiZXR3ZWVuIDIwMjAtMDgtMDEgJiAyMDIwLTA4LTEyLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhbWFkZXVzLnRyYXZlbC5wcmVkaWN0aW9ucy50cmlwUHVycG9zZS5nZXQoe1xuICAgKiAgICBvcmlnaW5Mb2NhdGlvbkNvZGU6ICdOWUMnLFxuICAgKiAgICBkZXN0aW5hdGlvbkxvY2F0aW9uQ29kZTogJ01BRCcsXG4gICAqICAgIGRlcGFydHVyZURhdGU6ICcyMDIwLTA4LTAxJyxcbiAgICogICAgcmV0dXJuRGF0ZTogJzIwMjAtMDgtMTInXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldCgnL3YxL3RyYXZlbC9wcmVkaWN0aW9ucy90cmlwLXB1cnBvc2UnLCBwYXJhbXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyaXBQdXJwb3NlOyJdfQ==