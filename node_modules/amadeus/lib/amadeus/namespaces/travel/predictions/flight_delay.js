"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A namespaced client for the
 * `/v1/travel/predictions/flight-delay` endpoints
 *
 * Access via the {@link Amadeus} object
 *
 * ```js
 * let amadeus = new Amadeus();
 * amadeus.travel.predictions.flightDelay;
 * ```
 *
 * @param {Client} client
 */
var FlightDelay =
/*#__PURE__*/
function () {
  function FlightDelay(client) {
    _classCallCheck(this, FlightDelay);

    this.client = client;
  }
  /**
   * This machine learning API is based on a prediction model that takes the input of
   * the user -time, carrier, airport and aircraft information- and
   * predict the segment where the flight is likely to lay.
   *
   * @param {Object} params
   * @param {string} params.originLocationCode city/airport IATA code to which the traveler is departing, e.g. PAR for Paris
   * @param {string} params.destinationLocationCode city/airport IATA code to which the traveler is departing, e.g. PAR for Paris
   * @param {string} params.departureDate the date on which the traveler will depart from the origin to go to the destination. Dates are specified in the ISO 8601 YYYY-MM-DD format, e.g. 2019-12-25
   * @param {string} params.departureTime local time relative to originLocationCode on which the traveler will depart from the origin. Time respects ISO 8601 standard. e.g. 13:22:00
   * @param {string} params.arrivalDate the date on which the traveler will arrive to the destination from the origin. Dates are specified in the ISO 8601 YYYY-MM-DD format, e.g. 2019-12-25
   * @param {string} params.arrivalTime local time relative to destinationLocationCode on which the traveler will arrive to destination. Time respects ISO 8601 standard. e.g. 13:22:00
   * @param {string} params.aircraftCode IATA aircraft code (http://www.flugzeuginfo.net/table_accodes_iata_en.php)
   * @param {string} params.carrierCode airline / carrier code
   * @param {string} params.flightNumber flight number as assigned by the carrier
   * @param {string} params.duration flight duration in ISO8601 PnYnMnDTnHnMnS format, e.g. PT2H10M
   * @return {Promise.<Response,ResponseError>} a Promise
   *
   * Predict the segment where LH1009 (BRU-FRA) is likely to lay on 2020-01-14
   *
   * ```js
   * amadeus.travel.predictions.flightDelay.get({
   *    originLocationCode: 'BRU',
   *    destinationLocationCode: 'FRA',
   *    departureDate: '2020-01-14',
   *    departureTime: '11:05:00',
   *    arrivalDate: '2020-01-14',
   *    arrivalTime: '12:10:00',
   *    aircraftCode: '32A',
   *    carrierCode: 'LH',
   *    flightNumber: '1009',
   *    duration: 'PT1H05M'
   * })
   * ```
   */


  _createClass(FlightDelay, [{
    key: "get",
    value: function get() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.client.get('/v1/travel/predictions/flight-delay', params);
    }
  }]);

  return FlightDelay;
}();

var _default = FlightDelay;
exports["default"] = _default;
module.exports = exports["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hbWFkZXVzL25hbWVzcGFjZXMvdHJhdmVsL3ByZWRpY3Rpb25zL2ZsaWdodF9kZWxheS5qcyJdLCJuYW1lcyI6WyJGbGlnaHREZWxheSIsImNsaWVudCIsInBhcmFtcyIsImdldCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0lBYU1BLFc7OztBQUNKLHVCQUFZQyxNQUFaLEVBQW9CO0FBQUE7O0FBQ2xCLFNBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFtQ2lCO0FBQUEsVUFBYkMsTUFBYSx1RUFBSixFQUFJO0FBQ2YsYUFBTyxLQUFLRCxNQUFMLENBQVlFLEdBQVosQ0FBZ0IscUNBQWhCLEVBQXVERCxNQUF2RCxDQUFQO0FBQ0Q7Ozs7OztlQUdZRixXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIG5hbWVzcGFjZWQgY2xpZW50IGZvciB0aGVcbiAqIGAvdjEvdHJhdmVsL3ByZWRpY3Rpb25zL2ZsaWdodC1kZWxheWAgZW5kcG9pbnRzXG4gKlxuICogQWNjZXNzIHZpYSB0aGUge0BsaW5rIEFtYWRldXN9IG9iamVjdFxuICpcbiAqIGBgYGpzXG4gKiBsZXQgYW1hZGV1cyA9IG5ldyBBbWFkZXVzKCk7XG4gKiBhbWFkZXVzLnRyYXZlbC5wcmVkaWN0aW9ucy5mbGlnaHREZWxheTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnRcbiAqL1xuY2xhc3MgRmxpZ2h0RGVsYXkge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1hY2hpbmUgbGVhcm5pbmcgQVBJIGlzIGJhc2VkIG9uIGEgcHJlZGljdGlvbiBtb2RlbCB0aGF0IHRha2VzIHRoZSBpbnB1dCBvZlxuICAgKiB0aGUgdXNlciAtdGltZSwgY2FycmllciwgYWlycG9ydCBhbmQgYWlyY3JhZnQgaW5mb3JtYXRpb24tIGFuZFxuICAgKiBwcmVkaWN0IHRoZSBzZWdtZW50IHdoZXJlIHRoZSBmbGlnaHQgaXMgbGlrZWx5IHRvIGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm9yaWdpbkxvY2F0aW9uQ29kZSBjaXR5L2FpcnBvcnQgSUFUQSBjb2RlIHRvIHdoaWNoIHRoZSB0cmF2ZWxlciBpcyBkZXBhcnRpbmcsIGUuZy4gUEFSIGZvciBQYXJpc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc3RpbmF0aW9uTG9jYXRpb25Db2RlIGNpdHkvYWlycG9ydCBJQVRBIGNvZGUgdG8gd2hpY2ggdGhlIHRyYXZlbGVyIGlzIGRlcGFydGluZywgZS5nLiBQQVIgZm9yIFBhcmlzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVwYXJ0dXJlRGF0ZSB0aGUgZGF0ZSBvbiB3aGljaCB0aGUgdHJhdmVsZXIgd2lsbCBkZXBhcnQgZnJvbSB0aGUgb3JpZ2luIHRvIGdvIHRvIHRoZSBkZXN0aW5hdGlvbi4gRGF0ZXMgYXJlIHNwZWNpZmllZCBpbiB0aGUgSVNPIDg2MDEgWVlZWS1NTS1ERCBmb3JtYXQsIGUuZy4gMjAxOS0xMi0yNVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlcGFydHVyZVRpbWUgbG9jYWwgdGltZSByZWxhdGl2ZSB0byBvcmlnaW5Mb2NhdGlvbkNvZGUgb24gd2hpY2ggdGhlIHRyYXZlbGVyIHdpbGwgZGVwYXJ0IGZyb20gdGhlIG9yaWdpbi4gVGltZSByZXNwZWN0cyBJU08gODYwMSBzdGFuZGFyZC4gZS5nLiAxMzoyMjowMFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFycml2YWxEYXRlIHRoZSBkYXRlIG9uIHdoaWNoIHRoZSB0cmF2ZWxlciB3aWxsIGFycml2ZSB0byB0aGUgZGVzdGluYXRpb24gZnJvbSB0aGUgb3JpZ2luLiBEYXRlcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBJU08gODYwMSBZWVlZLU1NLUREIGZvcm1hdCwgZS5nLiAyMDE5LTEyLTI1XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXJyaXZhbFRpbWUgbG9jYWwgdGltZSByZWxhdGl2ZSB0byBkZXN0aW5hdGlvbkxvY2F0aW9uQ29kZSBvbiB3aGljaCB0aGUgdHJhdmVsZXIgd2lsbCBhcnJpdmUgdG8gZGVzdGluYXRpb24uIFRpbWUgcmVzcGVjdHMgSVNPIDg2MDEgc3RhbmRhcmQuIGUuZy4gMTM6MjI6MDBcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5haXJjcmFmdENvZGUgSUFUQSBhaXJjcmFmdCBjb2RlIChodHRwOi8vd3d3LmZsdWd6ZXVnaW5mby5uZXQvdGFibGVfYWNjb2Rlc19pYXRhX2VuLnBocClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jYXJyaWVyQ29kZSBhaXJsaW5lIC8gY2FycmllciBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmxpZ2h0TnVtYmVyIGZsaWdodCBudW1iZXIgYXMgYXNzaWduZWQgYnkgdGhlIGNhcnJpZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kdXJhdGlvbiBmbGlnaHQgZHVyYXRpb24gaW4gSVNPODYwMSBQblluTW5EVG5Ibk1uUyBmb3JtYXQsIGUuZy4gUFQySDEwTVxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxSZXNwb25zZSxSZXNwb25zZUVycm9yPn0gYSBQcm9taXNlXG4gICAqXG4gICAqIFByZWRpY3QgdGhlIHNlZ21lbnQgd2hlcmUgTEgxMDA5IChCUlUtRlJBKSBpcyBsaWtlbHkgdG8gbGF5IG9uIDIwMjAtMDEtMTRcbiAgICpcbiAgICogYGBganNcbiAgICogYW1hZGV1cy50cmF2ZWwucHJlZGljdGlvbnMuZmxpZ2h0RGVsYXkuZ2V0KHtcbiAgICogICAgb3JpZ2luTG9jYXRpb25Db2RlOiAnQlJVJyxcbiAgICogICAgZGVzdGluYXRpb25Mb2NhdGlvbkNvZGU6ICdGUkEnLFxuICAgKiAgICBkZXBhcnR1cmVEYXRlOiAnMjAyMC0wMS0xNCcsXG4gICAqICAgIGRlcGFydHVyZVRpbWU6ICcxMTowNTowMCcsXG4gICAqICAgIGFycml2YWxEYXRlOiAnMjAyMC0wMS0xNCcsXG4gICAqICAgIGFycml2YWxUaW1lOiAnMTI6MTA6MDAnLFxuICAgKiAgICBhaXJjcmFmdENvZGU6ICczMkEnLFxuICAgKiAgICBjYXJyaWVyQ29kZTogJ0xIJyxcbiAgICogICAgZmxpZ2h0TnVtYmVyOiAnMTAwOScsXG4gICAqICAgIGR1cmF0aW9uOiAnUFQxSDA1TSdcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBnZXQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZ2V0KCcvdjEvdHJhdmVsL3ByZWRpY3Rpb25zL2ZsaWdodC1kZWxheScsIHBhcmFtcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmxpZ2h0RGVsYXk7Il19