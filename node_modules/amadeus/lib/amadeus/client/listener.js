"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _response = _interopRequireDefault(require("./response"));

var _util = _interopRequireDefault(require("util"));

var _errors = require("./errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Listen to changes in the HTTP request and build Response/ResponseError
 * objects accordingly.
 *
 * @param {Request} request the request object used to make the call
 * @param {EventEmitter} emitter a Node event emitter
 * @param {Client} client the client instance to log results to
 * @protected
 */
var Listener =
/*#__PURE__*/
function () {
  function Listener(request, emitter, client) {
    _classCallCheck(this, Listener);

    this.request = request;
    this.emitter = emitter;
    this.client = client;
  } // PROTECTED

  /**
   * Listens to various events on the http_response object, listening for data,
   * connections closing for bad reasons, and the end of the response.
   *
   * Used by the Client when making an API call.
   *
   * @param  {Object} http_response a Node http response object
   * @protected
   */


  _createClass(Listener, [{
    key: "onResponse",
    value: function onResponse(http_response) {
      var response = new _response["default"](http_response, this.request);
      http_response.on('data', response.addChunk.bind(response));
      http_response.on('end', this.onEnd(response).bind(this));
      http_response.on('close', this.onNetworkError(response).bind(this));
      http_response.on('error', this.onNetworkError(response).bind(this));
    }
    /**
     * Listens to a network error when making an API call.
     *
     * Used by the Client when making an API call.
     *
     * @param  {Object} http_response a Node http response object
     * @protected
     */

  }, {
    key: "onError",
    value: function onError(http_response) {
      var response = new _response["default"](http_response, this.request);
      this.onNetworkError(response)();
    } // PRIVATE

    /**
     * When the connection ends, check if the response can be parsed or not and
     * act accordingly.
     *
     * @param  {Response} response
     */

  }, {
    key: "onEnd",
    value: function onEnd(response) {
      var _this = this;

      return function () {
        response.parse();

        if (response.success()) {
          _this.onSuccess(response);
        } else {
          _this.onFail(response);
        }
      };
    }
    /**
     * When the response was successful, resolve the promise and return the
     * response object
     *
     * @param  {Response} response
     */

  }, {
    key: "onSuccess",
    value: function onSuccess(response) {
      this.log(response);
      this.emitter.emit('resolve', response);
    }
    /**
     * When the connection was not successful, determine the reason and resolve
     * the promise accordingly.
     *
     * @param  {Response} response
     */

  }, {
    key: "onFail",
    value: function onFail(response) {
      var Error = this.errorFor(response);
      var error = new Error(response);
      this.log(response, error);
      this.emitter.emit('reject', error);
    }
    /**
     * Find the right error for the given response.
     *
     * @param {Response} reponse
     * @returns {ResponseError}
     */

  }, {
    key: "errorFor",
    value: function errorFor(_ref) {
      var statusCode = _ref.statusCode,
          parsed = _ref.parsed;
      var error = null;

      if (statusCode >= 500) {
        error = _errors.ServerError;
      } else if (statusCode == 401) {
        error = _errors.AuthenticationError;
      } else if (statusCode == 404) {
        error = _errors.NotFoundError;
      } else if (statusCode >= 400) {
        error = _errors.ClientError;
      } else if (!parsed) {
        error = _errors.ParserError;
      } else {
        error = _errors.UnknownError;
      }

      return error;
    }
    /**
     * When the connection ran into a network error, reject the promise with a
     * NetworkError.
     *
     * @param  {Response} response
     */

  }, {
    key: "onNetworkError",
    value: function onNetworkError(response) {
      var _this2 = this;

      return function () {
        response.parse();
        var error = new _errors.NetworkError(response);

        _this2.log(response, error);

        _this2.emitter.emit('reject', error);
      };
    }
    /**
     * Logs the response, when in debug mode
     *
     * @param  {Response} response the response object to log
     * @private
     */

  }, {
    key: "log",
    value: function log(response, error) {
      if (this.client.debug()) {
        /* istanbul ignore next */
        this.client.logger.log(_util["default"].inspect(response, false, null));
      }

      if (!this.client.debug() && this.client.warn() && error) {
        /* istanbul ignore next */
        this.client.logger.log('Amadeus', error.code, error.description);
      }
    }
  }]);

  return Listener;
}();

var _default = Listener;
exports["default"] = _default;
module.exports = exports["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hbWFkZXVzL2NsaWVudC9saXN0ZW5lci5qcyJdLCJuYW1lcyI6WyJMaXN0ZW5lciIsInJlcXVlc3QiLCJlbWl0dGVyIiwiY2xpZW50IiwiaHR0cF9yZXNwb25zZSIsInJlc3BvbnNlIiwiUmVzcG9uc2UiLCJvbiIsImFkZENodW5rIiwiYmluZCIsIm9uRW5kIiwib25OZXR3b3JrRXJyb3IiLCJwYXJzZSIsInN1Y2Nlc3MiLCJvblN1Y2Nlc3MiLCJvbkZhaWwiLCJsb2ciLCJlbWl0IiwiRXJyb3IiLCJlcnJvckZvciIsImVycm9yIiwic3RhdHVzQ29kZSIsInBhcnNlZCIsIlNlcnZlckVycm9yIiwiQXV0aGVudGljYXRpb25FcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJDbGllbnRFcnJvciIsIlBhcnNlckVycm9yIiwiVW5rbm93bkVycm9yIiwiTmV0d29ya0Vycm9yIiwiZGVidWciLCJsb2dnZXIiLCJ1dGlsIiwiaW5zcGVjdCIsIndhcm4iLCJjb2RlIiwiZGVzY3JpcHRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7SUFTTUEsUTs7O0FBQ0osb0JBQVlDLE9BQVosRUFBcUJDLE9BQXJCLEVBQThCQyxNQUE5QixFQUFzQztBQUFBOztBQUNwQyxTQUFLRixPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxNQUFMLEdBQWVBLE1BQWY7QUFDRCxHLENBRUQ7O0FBR0E7Ozs7Ozs7Ozs7Ozs7K0JBU1dDLGEsRUFBZTtBQUN4QixVQUFJQyxRQUFRLEdBQUcsSUFBSUMsb0JBQUosQ0FBYUYsYUFBYixFQUE0QixLQUFLSCxPQUFqQyxDQUFmO0FBRUFHLE1BQUFBLGFBQWEsQ0FBQ0csRUFBZCxDQUFpQixNQUFqQixFQUEwQkYsUUFBUSxDQUFDRyxRQUFULENBQWtCQyxJQUFsQixDQUF1QkosUUFBdkIsQ0FBMUI7QUFDQUQsTUFBQUEs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QU1JZixRLEVBQVVlLEssRUFBTztBQUNuQixVQUFJLEtBQUtqQixNQUFMLENBQVkyQixLQUFaLEVBQUosRUFBeUI7QUFDdkI7QUFDQSxhQUFLM0IsTUFBTCxDQUFZNEIsTUFBWixDQUFtQmYsR0FBbkIsQ0FBdUJnQixpQkFBS0MsT0FBTCxDQUFhNUIsUUFBYixFQUF1QixLQUF2QixFQUE4QixJQUE5QixDQUF2QjtBQUNEOztBQUNELFVBQUksQ0FBQyxLQUFLRixNQUFMLENBQVkyQixLQUFaLEVBQUQsSUFBd0IsS0FBSzNCLE1BQUwsQ0FBWStCLElBQVosRUFBeEIsSUFBOENkLEtBQWxELEVBQXlEO0FBQ3ZEO0FBQ0EsYUFBS2pCLE1BQUwsQ0FBWTRCLE1BQVosQ0FBbUJmLEdBQW5CLENBQXVCLFNBQXZCLEVBQWtDSSxLQUFLLENBQUNlLElBQXhDLEVBQThDZixLQUFLLENBQUNnQixXQUFwRDtBQUNEO0FBQ0Y7Ozs7OztlQUdZcEMsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZXNwb25zZSBmcm9tICcuL3Jlc3BvbnNlJztcbmltcG9ydCB1dGlsICAgICBmcm9tICd1dGlsJztcblxuaW1wb3J0IHtcbiAgU2VydmVyRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIENsaWVudEVycm9yLFxuICBQYXJzZXJFcnJvcixcbiAgVW5rbm93bkVycm9yLFxuICBOZXR3b3JrRXJyb3IsXG4gIEF1dGhlbnRpY2F0aW9uRXJyb3Jcbn0gZnJvbSAnLi9lcnJvcnMnO1xuXG5cbi8qKlxuICogTGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBhbmQgYnVpbGQgUmVzcG9uc2UvUmVzcG9uc2VFcnJvclxuICogb2JqZWN0cyBhY2NvcmRpbmdseS5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3QgdGhlIHJlcXVlc3Qgb2JqZWN0IHVzZWQgdG8gbWFrZSB0aGUgY2FsbFxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgYSBOb2RlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgdGhlIGNsaWVudCBpbnN0YW5jZSB0byBsb2cgcmVzdWx0cyB0b1xuICogQHByb3RlY3RlZFxuICovXG5jbGFzcyBMaXN0ZW5lciB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QsIGVtaXR0ZXIsIGNsaWVudCkge1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB0aGlzLmNsaWVudCAgPSBjbGllbnQ7XG4gIH1cblxuICAvLyBQUk9URUNURURcblxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHZhcmlvdXMgZXZlbnRzIG9uIHRoZSBodHRwX3Jlc3BvbnNlIG9iamVjdCwgbGlzdGVuaW5nIGZvciBkYXRhLFxuICAgKiBjb25uZWN0aW9ucyBjbG9zaW5nIGZvciBiYWQgcmVhc29ucywgYW5kIHRoZSBlbmQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBVc2VkIGJ5IHRoZSBDbGllbnQgd2hlbiBtYWtpbmcgYW4gQVBJIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gaHR0cF9yZXNwb25zZSBhIE5vZGUgaHR0cCByZXNwb25zZSBvYmplY3RcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgb25SZXNwb25zZShodHRwX3Jlc3BvbnNlKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGh0dHBfcmVzcG9uc2UsIHRoaXMucmVxdWVzdCk7XG5cbiAgICBodHRwX3Jlc3BvbnNlLm9uKCdkYXRhJywgIHJlc3BvbnNlLmFkZENodW5rLmJpbmQocmVzcG9uc2UpKTtcbiAgICBodHRwX3Jlc3BvbnNlLm9uKCdlbmQnLCAgIHRoaXMub25FbmQocmVzcG9uc2UpLmJpbmQodGhpcykpO1xuICAgIGh0dHBfcmVzcG9uc2Uub24oJ2Nsb3NlJywgdGhpcy5vbk5ldHdvcmtFcnJvcihyZXNwb25zZSkuYmluZCh0aGlzKSk7XG4gICAgaHR0cF9yZXNwb25zZS5vbignZXJyb3InLCB0aGlzLm9uTmV0d29ya0Vycm9yKHJlc3BvbnNlKS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIGEgbmV0d29yayBlcnJvciB3aGVuIG1ha2luZyBhbiBBUEkgY2FsbC5cbiAgICpcbiAgICogVXNlZCBieSB0aGUgQ2xpZW50IHdoZW4gbWFraW5nIGFuIEFQSSBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGh0dHBfcmVzcG9uc2UgYSBOb2RlIGh0dHAgcmVzcG9uc2Ugb2JqZWN0XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgb25FcnJvcihodHRwX3Jlc3BvbnNlKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGh0dHBfcmVzcG9uc2UsIHRoaXMucmVxdWVzdCk7XG4gICAgdGhpcy5vbk5ldHdvcmtFcnJvcihyZXNwb25zZSkoKTtcbiAgfVxuXG4gIC8vIFBSSVZBVEVcblxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIGVuZHMsIGNoZWNrIGlmIHRoZSByZXNwb25zZSBjYW4gYmUgcGFyc2VkIG9yIG5vdCBhbmRcbiAgICogYWN0IGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIG9uRW5kKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc3BvbnNlLnBhcnNlKCk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcygpKSB7IHRoaXMub25TdWNjZXNzKHJlc3BvbnNlKTsgfVxuICAgICAgZWxzZSB7IHRoaXMub25GYWlsKHJlc3BvbnNlKTsgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsLCByZXNvbHZlIHRoZSBwcm9taXNlIGFuZCByZXR1cm4gdGhlXG4gICAqIHJlc3BvbnNlIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIG9uU3VjY2VzcyhyZXNwb25zZSkge1xuICAgIHRoaXMubG9nKHJlc3BvbnNlKTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdCgncmVzb2x2ZScsIHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHdhcyBub3Qgc3VjY2Vzc2Z1bCwgZGV0ZXJtaW5lIHRoZSByZWFzb24gYW5kIHJlc29sdmVcbiAgICogdGhlIHByb21pc2UgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSAge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgb25GYWlsKHJlc3BvbnNlKSB7XG4gICAgbGV0IEVycm9yID0gdGhpcy5lcnJvckZvcihyZXNwb25zZSk7XG4gICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHJlc3BvbnNlKTtcbiAgICB0aGlzLmxvZyhyZXNwb25zZSwgZXJyb3IpO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KCdyZWplY3QnLCBlcnJvcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSByaWdodCBlcnJvciBmb3IgdGhlIGdpdmVuIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXBvbnNlXG4gICAqIEByZXR1cm5zIHtSZXNwb25zZUVycm9yfVxuICAgKi9cbiAgZXJyb3JGb3Ioe3N0YXR1c0NvZGUsIHBhcnNlZH0pIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGlmIChzdGF0dXNDb2RlID49IDUwMCkgeyBlcnJvciA9IFNlcnZlckVycm9yOyB9XG4gICAgZWxzZSBpZiAoc3RhdHVzQ29kZSA9PSA0MDEpIHsgZXJyb3IgPSBBdXRoZW50aWNhdGlvbkVycm9yOyB9XG4gICAgZWxzZSBpZiAoc3RhdHVzQ29kZSA9PSA0MDQpIHsgZXJyb3IgPSBOb3RGb3VuZEVycm9yOyB9XG4gICAgZWxzZSBpZiAoc3RhdHVzQ29kZSA+PSA0MDApIHsgZXJyb3IgPSBDbGllbnRFcnJvcjsgfVxuICAgIGVsc2UgaWYgKCFwYXJzZWQpIHsgZXJyb3IgPSBQYXJzZXJFcnJvcjsgfVxuICAgIGVsc2UgeyBlcnJvciA9IFVua25vd25FcnJvcjsgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHJhbiBpbnRvIGEgbmV0d29yayBlcnJvciwgcmVqZWN0IHRoZSBwcm9taXNlIHdpdGggYVxuICAgKiBOZXR3b3JrRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgb25OZXR3b3JrRXJyb3IocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVzcG9uc2UucGFyc2UoKTtcbiAgICAgIGxldCBlcnJvciA9IG5ldyBOZXR3b3JrRXJyb3IocmVzcG9uc2UpO1xuICAgICAgdGhpcy5sb2cocmVzcG9uc2UsIGVycm9yKTtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KCdyZWplY3QnLCBlcnJvcik7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSByZXNwb25zZSwgd2hlbiBpbiBkZWJ1ZyBtb2RlXG4gICAqXG4gICAqIEBwYXJhbSAge1Jlc3BvbnNlfSByZXNwb25zZSB0aGUgcmVzcG9uc2Ugb2JqZWN0IHRvIGxvZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbG9nKHJlc3BvbnNlLCBlcnJvcikge1xuICAgIGlmICh0aGlzLmNsaWVudC5kZWJ1ZygpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmxvZyh1dGlsLmluc3BlY3QocmVzcG9uc2UsIGZhbHNlLCBudWxsKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQuZGVidWcoKSAmJiB0aGlzLmNsaWVudC53YXJuKCkgJiYgZXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aGlzLmNsaWVudC5sb2dnZXIubG9nKCdBbWFkZXVzJywgZXJyb3IuY29kZSwgZXJyb3IuZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0ZW5lcjtcbiJdfQ==